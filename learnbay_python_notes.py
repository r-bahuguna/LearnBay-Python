# -*- coding: utf-8 -*-
"""LearnBay Python Notes

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15A5R-FUrOuI_cisHSm8UVQ2G6FYlgbb6

# Important URLs 
  - [Markdown writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)
  - [Jupyter Notebook Help](https://nbviewer.org/github/ipython/ipython/blob/3.x/examples/Notebook/Index.ipynb)
  - [Python documentation](https://docs.python.org/3.9/)
  - [iPython documentation](https://ipython.org/documentation.html?v=20220703072139)
  - [Colab Markdown guide](https://colab.research.google.com/notebooks/markdown_guide.ipynb#scrollTo=w86a4I4fmkvD)

# ***-------->CORE PYTHON<--------***

# Variables 
  - containers for storing data
  - name for a reserved memory location
  - created when initialised 
  ```
  var = "Hello World"                # initializing var variable with a string literal
  ```

### Naming Convention
  - starts with letter or underscore
  - can't start with a number 
   ```
  # incorrect syntax
  1var = 10                          # --> SyntaxError
  2var = 20                          # --> SyntaxError
  ```
  - can contain only letters, numbers or underscore
  - **Names are Case Sensitive** 
  ``` 
  # these are two different variables:
  x = 10 
  X = 20 
  ```
  - we can assign single value to multiple variables 
   ``` 
   a = b = c = 10 
   ```
  - *Keywords* should not be variable names 
   ```
   help('keywords')
   ``` 
   or 
  ```
  import keyword
  keyword.kwlist
  ```

# Comments
  - make code more readable
  - prevent code execution
  ```
     # This is a comment
     # print('Uncomment to print this statement')
  ```
  - Triple quotes can be used to write multi-line comments
  ```
  '''
  This is 
  a multi-line
  comment
  '''
  ```

# Escape Characters
  - New line -> ```\n```
  - Tab (4 spaces) -> ```\t```

# Input/ Output
  - Input 
   ```
   usr_input = input("Enter user input: ")
   ```
  - Output
   ```
   print(usr_input)
   ```

# Data Types
  - ### Non Sequence
    - Numeric
     - Int
     - Float
     - Complex Numbers
     ```
     comp_num = 2 + 3j
     type(comp_num)        # Complex
     ```
    - Boolean
    ```
    x = True
    y = False
    ```

  - ### Sequence
    - #### Ordered:
      - String
      
      ```
      message = 'Hello World'
      message[0]           # Output: 'H' -> called Indexing
      len(message)         # Output: 11 -> len function only works on sequencial data types
      mesage[0] = 'Z'      # Throws error -> because strings are immutable

      # Use triple quotes for multi-line strings
      x = '''              
      Hey, this is 
      a multi-line 
      string
      '''

      y = '''
      This is
      another multi-line
      string
      '''
      ```
      - List

      ```
      # List is hetrogenous
      # Elements in list can be repeated
      # List is mutable,
      list1 = [2, 2.5, 'hello', [0, 'World'], 2, 2.5, True, (1-4j)]
      list1[3][1]              # Output: 'World'
      list1[2] = 'Hi'          # modifying 3rd element of the list
      list1[0] = str(list1[0]) # converting 1st value of the list to string - called Type Casting
      list2 = [[0, 1], [2, 3]] # 2 dimensional list

      ```

      - Tuple

      ```
      # Tuple is hetrogenous
      # Elements in a tuple can be repeated
      # Tuple is immutable
      tuple1 = (2, 2.5, 'hello', [0, 'World'], 2, 2.5, True, (1-4j))
      tuple1[3] = 'Hi'          # Throws TypeError as tuple can't be modified
      tuple1[3][1] = 'Hi'       # modifying elements inside a mutable element of a tuple is possible
      var1 = 1, 2, 3, 'Hi'      # Output: (1, 2, 3, 'Hi') -> automatically becomes a tuple
      var2 = (12)               # Output: 12 -> automatically becomes an int
      var3 = (12,)              # Output: (12,) -> correct way to create a tuple with single element
      ```
    - #### Unordered
      - Dictionary
        - stores values like a map, i,e, key:value pair
        - Dictionary as a whole is mutable
          - Keys are immutable
            - they can't be repeated
            - they will always be immutable data type
          - Values are mutable
            - they can be repeated
            - they can be im/mutable data type
            
            ```
            dict1 = {'Name':'Rick', True:1, False:1, 2:['Hello', 'World'], 2:['Hi', 'Rick'] }
            dict1[2]               # Output: ['Hi', 'Rick'] - keys can't be repeated
            dict1['Name']          # Output: 'Rick' - value can be accessed from key
            dict1['Name'] = 'John' # modifying a value using key
            dict1['Rick']          # Throws KeyError as key can't be accessed from value

            # To access keys in a dictionary, we can use a for loop:

            for keys in dict1:
              print(keys)

            ```

      - Set 
        - elements of a set are unique
        - Set as a whole is mutable, however, **elements of set are immutable**
        ```
        # Hashing is used to store data in memory
        # does not return elements of set in a particular order
        set1 = {1,2,2,2,3,4,4.5,5}
        set1                       # Output: {1,2,3,4,4.5,5}                                        
        # Mutating set as a whole
        set1.add(6) 
        set1.remove(4.5)
        set1                       # Output: {1, 2, 3, 4, 5, 6}
        ```

# Immutable Vs Mutable Data Types

  - Immutable Data Types:
    - Numeric
    - Boolean
    - String
    - Tuple
  - Mutable Data Types:
    - List
    - Dictionary
    - Set

# Type Casting
  meaning - converting data type of of one data to another ***compatible*** data type
  ```
  # converting int to float
  num = 2
  float(num)                      # Output: 2.0
  # converting int to string
  num1 = 23
  str(num1)                       # Output: '23'
  # converting list to tuple
  list1 = [1, 2, 3, 4]
  tuple(list1)                    # Output: (1, 2, 3, 4)
  # Incompatible Type Casting
  str1 = 'a1'
  int(str1)                       # Throws ValueError
  # Converting a list to dictionary
  list1 = [1, 2, 3, 4]
  dict(list1)                     # Throws TypeError
  # Converting a 2 dimensional list/ tuple to dictionay is possible
  list2 = [[1, 2], [3, 4]]
  dict(list2)                     # Output: {1: 2, 3: 4}
  # Converting list to set
  list3 = [1, 2, [1, 2, 3]]
  set(list3)                      # Throws TypeError because elements of list are always immutable
  list4 = [1, 2, (1, 2, 3)]
  set(list4)                      # Output: {(1, 2, 3), 1, 2}
  # converting dictionary to list/ tuple
  dict1 = {'Name':'Rick', 'Score':42, 'Age':24}
  list(dict1)                     # Output: ['Name', 'Score', 'Age']  -> stores only keys
  ```
  #### Type Casting User Input:
  ```
  usr_input = input('Enter your marks: ')     # By default it will be a string data type
  int_usr_input = int(float(usr_inpput))      # Converting user input to int 

  ```
  #### Type Casting int to Boolean
  ```
  bool(0)                                     # Output: False
  bool(1)                                     # Output: True -> boolean of any int except 0 is True
  ```

# Types of Operators
  - Arithmetic Operators
  ```
   +, -, /, //, **, %
   # Devision Operator:
   3 / 1                     # Output: 3.0 -> always gives float value 
   # Modulus Operator:
   5 % 2                     # Output: 1 -> data type of value depends on dividend
   # Power Operator:
   2 ** 2                    # Output: 4 -> data type of value depends on dividend
   # Floor Division:
   5.0 // 2                  # Output: 2.0 -> data type of value depends on dividend
  ```
  - Assignment Operators
  ```
  =, +=, -=, *=, /=, //=, **=, %=
  x = 5
  x += 1                       # Output: 6 -> Increment Operator
  x -= 3                       # Output: 3 -> Decrement Operator
  ```
  - Comparison Operators
  ```
  ==, !=, >, <, >=, <=         # Output is always a Boolean Value
  # != and == are called also Equality Operators
  x == 3.                      # Output: True
  x != 3                       # Output: False
  a > b                        # Output: False -> compares ASCII value
  'red' > 'real'               # Output: True
  ```
  - Logical Operators
  ```
  and, or, not                 # i/p and o/p will be Boolean value
  # and operator returns True if both i/ps are True
  # or operator returns True if either i/p is Ture
  # not operator negates/ onverts the o/p, i.e., True becomes False and vice-versa
  True and True                # Output: True
  True and False               # Output: False
  True or True                 # Output: True
  True or False                # Output: False
  rain = True
  t_storm = True
  wind = False
  rain and t_storm and wind    # Output: False 
  # and finds False and returns 2nd value if 1st is True and vice-versa
  1 and 2                      # Output: 2
  # or finds True and returns 2nd value if 1st is False and vice-versa
  0 or 1                       # Output: 1       
  ```
  - Bitwise Operators
  ```
  &, |, ^
  # Bitwise and 
  4 & 11                       # Output: 0
  # Bitwise or
  4 | 11                       # Output: 4
  # Bitwise XOR
  # it means o/p will be High for different i/ps and Low for same i/ps
  4 ^ 11                       # Output: 15
  ```
  - Membership Operators
  ```
  in, not in
  str1 = 'Hello World'
  'H' in str1                  # Output: True
  'W' not in str1              # Output: False
  list1 = [1, 2, 3, 4]
  4 in list1                   # Output: True
  5 not in list1               # Output: True
  ```
  - Identity Operators

# Conditional Statements
```
# Syntax
if condition/boolenaConstraint:
    task_that_needs_to_be_exeuted_when_condition_is_True           # Indentation is used for statement blocks
else:
    task_that_needs_to_be_exeuted_when_condition_is_False          # Else statement is optional
```
#### Example - Pass/ Fail System:
```
marks = int(input('Enter marks: '))
if marks > 40:
    print('Passed')
    print('Good Job!')
else:
    print('Failed')
    print('You need to work harder.')
```
#### Nested Statements:
```
marks = int(input('Enter marks: '))
if 0 <= marks <= 100:                              # Parent If
    if marks > 40:                                 # Child If
        print('Passed')
        print('Good Job!')
    else:                                          # Child Else
        print('Failed')
        print('You need to work harder.')
else:
    print('Invalid input..')
```
#### Grading system with nested statements:
```
marks = int(input('Enter marks: '))
if marks > 90:
    print('Grade A+')
else:
    if marks > 80:
        print('Grade A')
    else:
        if marks > 70:
            print('Grade B+')
        else:
            print('something')
```
#### Grading system with elif statements:
```
marks = int(input('Enter marks: '))
if marks > 90:
    print('Grade A+')
elif marks > 80:
    print('Grade A')
elif marks >70:
    print('Grade B+')
else:
    print('something')
```
#### Ladder If Statements:
 *(used when multiple statements can be True)*
```
marks = int(input('Enter marks: '))
if marks > 90:
    print('Grade A+')
if marks > 80:
    print('Grade A')
if marks >70:
    print('Grade B+')
```

# Loops

- For Loops
  - when num of iterations is known
  - it is directly related to a sequential data type
  - else block is oprional

  ```
  # print 'Hello' 10 times:
  for i in range(10):
    print("hello")

  # print charaters of a string:
  for i in 'Hello':
    print(i)

  # print all items of a list:
  for i in [1, 2, 3, 4, 'Hello', True]:
    print(i)

  # print keys of a dictionary:
  for i in {1:'Hi', 2:"World"}:
    print(i)

  # gives us better control over elements of iterable
  h = "hello"
  for x in range(len(h)):
    print(h[x])

  # grading system for known number of students
  for i in range(5):
    marks = int(input("Enter marks: "))
    if marks >= 40:
      print('Passed')
    else:
      print('Failed')

  ```
  
- While Loops
  - when condotion to control iteration is known
  - it is directly dependent on a boolean

  ```
  # print numbers from 0 to 4:
  x = 0
  while x < 5:
    print(x)
    x += 1

  # another example of while loop:
  while "x" in ['a', 'b', 'x']:
    print('x')
    break                                 # Output: x

  # grading system when number of students is unknown
  # using flag variable
  flag = True
  while(flag):
    marks = int(input("Enter -1 to STOP \nEnter marks: "))
    if marks == -1:
      flag = not flag
    elif marks > 40:
      print("Passed")
    else:
      print('Failed')

  ```

# Jump Statements

- Break - *it is used to terminate loop*

```
for i in range(10):
  if i == 5:
    break                           # terminates loop at 5th iteration
    print(i)
```

- Continue - *it is used to terminate any iteration of a loop and return control to the beginning of the loop*

```
for i in range(10):
  if i == 5:
    continue                        # skips 5th iteration and continues with rest
  print(i)
```

- Pass - *it is a null statement, used as a placeholder when user doesn't know what code to write*

```
marks = 50

if marks > 40:
  pass
else:
  pass                              # no output and no error
```

# for-else statement

*returns code block in 'else' only if the loop runs successfully without any break*

  ```
for i in range(10):
  if i == 10:
    break
  print(i)
else:
  print('Loop ran successfully without break')             # 'else' code block will run because break statement is not executed

  ```

# Operations on Sequential Data types:

# Operations on Strings:

```
s1 = 'Hello'
s2 = 'World'

# Concatination:
s3 = s1 + ' ' + s2

# Repitition:
s1 * 2

# Slicing:
s3[2:7]

s3[::2]

s3[::-1]         # Reverse Slicing

```

# Methods on Strings:

```
# find() method 
# gives index # of 1st occurence of substring

s4 = 'Hello World! How are you all ?'

s4.find('o')

s4.find('H', 10, 20)

# gives output -1 if substring is not found

s4.find('z')                               # Output: -1

# find all the occurences of a substring:

ind = -1
for i in range(len(s4)):
  ind = s4.find('H', ind +1)
  if ind == -1:
    break
  print(ind)

```

```
# enumerate() function:

s4 = 'Hello World! How are you all ?'

for i, c in enumerate(s4):
  if c == 'H':
    print(i)
    
```

```

# index() method:
# it is same as find() method
# it gives error when substring is not found

s4 = 'Hello World! How are you all ?'

s4.index('H')
s4.index('z')                      # ---> ValueError


```

```
# replace() method:

s4 = 'Hello World! How are you all ?'

s4.replace('How', 'Why')

```

```
# count() method:

s4 = 'Hello World! How are you all ?'

s4.count('H')
```

```
# split() method:

s4 = 'Hello World! How are you all ?'

s4.split(' ')

# we can give number of count for split

dob = '01/09/1995'

dob.split('/', 1)
```

```
# mthods to change case:

name = 'Slim Shady'

name.upper()                         # Output: SLIM SHADY

name.lower()                         # Output: slim shady

name.title()                         # Output: Slim Shady

name.capitalize()                    # Output: Slim shady
```

```
# # returns char based on ASCII value:

max(name)                            # Output: y

min(name)                            # Output: ' '

```

```
# methods to check case:

name = 'Slim Shady'
name_upper = name.upper()
name_lower = name.lower()
name_title = name.title()

name_upper.isupper()                       # Output: True
name_lower.islower()                       # Output: True
name_title.istitle()                       # Output: True
name.isalpha()                             # Output: False ---> due to space character

'123'.isdigit()                            # Output: True
'Hello123'.isalnum()                       # Output: True


```

```
# join() method:

l = ['a', 'b', 'c', 'd']

' '.join(l)                        # Output: a b c d
':'.join(l)                        # Output: a:b:c:d  
```

# Operations on Lists:

```
l1 = [1, 2, 3, 4]
l2 = [5, 6, 7, 8]

# Concatination:
l1 + l2                           # Output: [1, 2, 3, 4, 5, 6, 7, 8]

# Repetition: 
l1 * 2                            # Output: [1, 2, 3, 4, 1, 2, 3, 4]

# Slicing:
l1[::-1]                          # Output: [4, 3, 2, 1]
```
# Methods on Lists

```
# append() method:

l1 = [1, 2, 3, 4]
l2 = [5, 6, 7, 8]

l1.append(5)
l1                                          # Output: [1, 2, 3, 4, 5]

l1.append([6, 7, 8])
l1                                          # Output: [1, 2, 3, 4, 5, [6, 7, 8]]

l1.append(l2)
l1                                          # Output: [1, 2, 3, 4, 5, [6, 7, 8], [5, 6, 7, 8]]

```

```
# extend() method:

l2 = [5, 6, 7, 8]
l2.extend([9, 10, 11])
l2                                          # Output: [5, 6, 7, 8, 9, 10, 11]
```

```
# insert() method: 

names = ['John', 'Key', 'Peele', 'Tom']

names.insert(3, 'Harry')
names                                        # Output: ['John', 'Key', 'Peele', 'Harry', 'Tom']
```

```
# pop() method:
# default index is -1

names = ['John', 'Key', 'Peele', 'Tom']

names.pop()
names                                        # Output: ['John', 'Key', 'Peele']

names.pop(0)
names                                        # Output: ['Key', 'Peele']   
```

```
# remove() method:

names = ['John', 'Key', 'Peele', 'Tom']

names.remove('John')
names                                        # Output: 'Key', 'Peele', 'Tom']
```

```
# count() method:

names = ['John', 'Key', 'Peele', 'Tom', 'Tom']
names.count('Tom')                         # Output: 2

for i in range(names.count('Tom')):
  if 'Tom' in names:
    names.remove('Tom')

names                                      # Output: ['John', 'Key', 'Peele']
```

```
# del function:

names = ['John', 'Key', 'Peele', 'Tom', 'Tom']

del names[0]

names                               # Output: ['Key', 'Peele', 'Tom', 'Tom']
```

```
# copy() method:

names = ['John', 'Key', 'Peele', 'Tom', 'Tom']

names_copy = names.copy()

names_copy.pop()

print(names)                         # Output: ['John', 'Key', 'Peele', 'Tom', 'Tom']
print(names_copy)                    # Output: ['John', 'Key', 'Peele', 'Tom']

```

```
# clear() method:

names = ['John', 'Key', 'Peele', 'Tom', 'Tom']

names.clear()

names                         # Output: names = []

```

```
# sort() method:

l = [9, 4, 7, 2, 5, 1]

l.sort()

l                       # Output: [1, 2, 4, 5, 7, 9]

l.sort(reverse = True)

l                       # Output: [9, 7, 5, 4, 2, 1]
```

```
# reverse() method:

l = [9, 4, 7, 2, 5, 1]

l.reverse()

l                        # Output: [1, 5, 2, 7, 4, 9]
```

# String Formatting:

- Formatting with % Operator:

```
x = 10
y = 20

print('Sum of %s and %s is %s'%(x, y, x+y))          # Output: Sum of 10 and 20 is 30
```

- Formatting with format() method:

```
print('This is a {} string'.format('formatted'))                    # Output: This is a formatted string

print('This is another {t} string.'.format(t = 'formatted'))        # Output: This is another formatted string.

print('{2} {0} {1}.'.format( 'is', 'Slim Shady', 'My name'))        # Output: My name is Slim Shady.
```

- formatting with string literals, called, f-strings

```
f_name = 'Greatest'
l_name = 'Ever'

print(f'Last name {l_name}, first name {f_name}.')             # Output: Last name Ever, first name Greatest.
```

# Operations on Tuples:

- Only those methods will work that don't modify the Tuple because Tuples are immutable. For eg, copy(), clear(), append(), extend(), etc.

- Methods on Tuple:


```

# index() method:

t = (1, 2, 3, 4, 5)

t[1]                                 # Output: 2

# count() method:

t.count(1)                           # Output: 1

# max() function:

max(t)                               # Output: 5

# min() function: 

min(t)                               # Output: 1

# type() function:

type(t)                              # Output: tuple

```

# Methods on Dictonaries:

- Operations like concatination, repetition, slicing and indexing are not possible because Dictionaries are unordered

```
# update method()

d = {1 : True, 2 : False, 3 : 'Hi'}


d.update({1 : False, 4 : "Hello"})

d                                          # Output: {1: False, 2: False, 3: 'Hi', 4: 'Hello'}

d[2] = True

d                                          # Output: {1: False, 2: True, 3: 'Hi', 4: 'Hello'}

d[5] = "World"

d                                          # Output: {1: False, 2: True, 3: 'Hi', 4: 'Hello', 5: 'World'}

# get() method:

print(d.get(5))                            # Output: World

print(d.get(7))                            # Output: None


# pop() method:

d.pop(5)

d                                          # Output: {1: False, 2: True, 3: 'Hi', 4: 'Hello'}


# del function:

del d[1]

d                                         # Output: {2: True, 3: 'Hi', 4: 'Hello'}

# keys() method:
# gives iterable, not a sequence

d.keys()                                  # Output: dict_keys([2, 3, 4]) 

# items() method:

d.items()                                 # Output: dict_items([(2, True), (3, 'Hi'), (4, 'Hello')])

# values() method:

d.values()                                # Output: dict_values([True, 'Hi', 'Hello'])


for x, y in d.items():
  print('x = ', x, end = '\t')
  print('y = ', y, end = ' ')            # Output: x =  2	y =  True x =  3	y =  Hi x =  4	y =  Hello 


```

# Operations on Sets:

```
# Uninon operation:

se1 = {1, 3, 5, 7}

se2 = {2, 4, 6, 8}

se1 | se2                                # Output: {1, 2, 3, 4, 5, 6, 7, 8}
se1.union(se2)                           # Output: {1, 2, 3, 4, 5, 6, 7, 8}
```

```
# intersection

se1 = {1, 3, 5, 7, 9}

se2 = {2, 4, 6, 8, 9}

se1 & se2                                # Output: 9
se1.intersection(se2)                    # Output: 9
```

```
# Difference:

se2 - se1                                # Output: {2, 4, 6, 8}
se2.difference(se1)                      # Output: {2, 4, 6, 8}

se1 - se2                                # Output: {1, 3, 5, 7}
se1.difference(se2)                      # Output: {1, 3, 5, 7}
```

# Methods on Sets:

```
s = {1, 2, 3, 4, 5}

# add() method:

s.add(6)

s                            # Output: {1, 2, 3, 4, 5, 6}


# remove() method:
# throws error if value does not exist

s.remove(6) 

s                            # Output: {1, 2, 3, 4, 5}


# discard() method:
# output is None if value does not exist

s.discard(1)

s                            # Output: {2, 3, 4, 5}


# pop() method:
# randomly removes a value

s.pop()

s                            # Output: {3, 4, 5}


```

# List Comprehension:

```
li1 = ['1', '2', '3', '4', '5', '6', '7', '8', '9']

li2 = []

for i in range(len(li1)):
  li2.append(int(li1[i]))

li2                                             # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

```
# same operation using list comprehension:

li1 = ['1', '2', '3', '4', '5', '6', '7', '8', '9']

li2 = [int(li1[i]) for i in range(len(li1))]

li2                                             # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

```
# create a list of squares of numbers till n:

n = 10

l = [i ** 2 for i in range(1, n+1)]

l                                               # Output: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]



# create a list of squares of numbers till n 
# for only even numbers:

n = 10

l = [i ** 2 for i in range(1, n+1) if i % 2 == 0]

l                                              # Output: [4, 16, 36, 64, 100]



```

# Functions

- Only Syntax Errors are thrown while defining a function
- Run Time Errors are thrown when a function is called

```
# defining a function: 

def function_name(parameter):
  print(f'This function prints {parameter}')

# calling a function:

function_name("Hello")                             # Output: This function prints Hello
```

```
def square(number):
  print(number ** 2)

square(4)                                          # Output: 16
```

- Variales defined inside function have a **local scope**

```
x = 10
y = 20
global_z = 30

def add():
  local_z = x + y + 20

print(f'Global variable: {global_z} ')                  # Output: Global variable: 30 

print(local_z)                                          # Name Error - because local_z is available locally inside add() function

```

- We can *return* the value of local variable to the **Calling Scope**

```
2x = 10
y = 20

def add():
  local_z = x + y
  return local_z

global_z = add()

print(global_z)                                           # Output: 30

```

- statements after 'return' keyword are not executed
- by default None is returned if nothing is mentioned after return keyword

```
def no_return():
    print('Hi')
    return
    print('World')

no_return()                                 # Output: Hi
print(no_return())                          # Output: Hi \n None

```

## Types of Arguements

- Positional Required Arguements
    - Number of parameters in function should be same as that in function definition
    - The data is passed in the positional order of arguements  

```
def nums(x, y):
    print(f'First arg: {x}\t Second arg: {y}')
    return

nums(2, 4)              # Output: First arg: 2	 Second arg: 4

```

- Keyword Arguements
    - Number of parameters in function should be same as that in function definition
    - Positional order doesn't matter while passing data according keywords

```

def nums(x, y):
    print(f'First arg: {x}\t Second arg: {y}')
    return

nums(y = 2, x = 4)              # Output: First arg: 4	 Second arg: 2

```



- Default Arguements
    - Number of arguements in function call can be 0 of max as per number of default arguements in function definition

```
def nums(x = 2, y = 4):
    print(f'First arg: {x}\t Second arg: {y}')
    return

nums()              # Output: First arg: 2	 Second arg: 4
nums(x = 1, y = 2). # Output: First arg: 1	 Second arg: 2

```


- Variable Length Arguements
    - Non-Keyword
        - We use this when we don't know how many arguements need to be passed.
        - The data passed in variable length arguement gets saved in a tuple.

    ```
def nums(x, *y):
    print(f'First arg: {x}\t Second arg: {y}')
    return
nums(2)             # Output: First arg: 2	 Second arg: ()
nums(1, 2, 3, 4)    # Output: First arg: 1	 Second arg: (2, 3, 4)

    ```

    - Keyworded
        - Data passed in keyorded variable length arguement gets saved in a dictionary.

    ```
    def nums(x, **y):
    print(f'First arg: {x}\t Second arg: {y}')
    return
nums(2, Name = "John", Age = 23, Region = "Texas")    
# Output: First arg: 2	 Second arg: {'Name': 'John', 'Age': 23, 'Region': 'Texas'}
     ```


## lambda function / Anonymous Function: 
>We can create a function in one line and use it without assigning an identifier/ func name.


```
# functionName = lambda arg1, arg2 : expression

lambda_function = lambda x, y : x + y

lambda_function(2, 3)

```

## map() Function

>- Init signature: map(\*args, **kwargs)
- map(func, *iterables) --> map object 

Make an iterator that computes the function using arguments from
each of the iterables.  Stops when the shortest iterable is exhausted.

```
l = list('123456')
print(l)                # Output: ['1', '2', '3', '4', '5', '6']
l1 = list(map(int, l))
l1                      # Output: [1, 2, 3, 4, 5, 6]

```
```
l = [1, 2, 3, 4, 5, 6]

list(map(lambda x : x**2, l))       # Output: [1, 4, 9, 16, 25, 36]

```


## filter() function:

> - Init signature: filter(\*args, **kwargs)
- ilter(function or None, iterable) --> filter object

Return an iterator yielding those items of iterable for which function(item)
is true. If function is None, return the items that are true.

```
l = [1, 2, 3, 4, 5, 6]

list(filter(lambda x : x % 2 == 0, l))      # Output: [2, 4, 6]

```

# Modules

- Module is same as a code library
- It is a set of functions you want to include in your application to improve the functionality

## Library 
- In-built library
- User-defined library / Module
- Packages

```
import platform             # imports 'platform' namespace and creates a reference in Main namespace for platform namespace
print(platform.system())    # Output: Linux
```

```
import os
os.mkdir('some')
os.rmdir('some')
```

```
import math

math.ceil(3.5)              # Output: 4
math.floor(3.5)             # Output: 3
math.pi                     # Output: 3.141592653589793
```

```
# we can import all/ specific names from a module in Main gloabl/ current namespace

from math import ceil, pi

pi                         # Output: 3.141592653589793
ceil(3.5)                  # Output: 4

# To import all the names in current namespace from a mmodule:

from math import *
```

```
# aliasing 

import numpy as np

np.ceil(3.5)            # Output: 4

np.eye(2, dtype=int)
#Output:
# array([[1, 0],
#        [0, 1]])
```

## User-defined / Custom Module

```
from google.colab import drive
drive.mount('/content/gdrive')
```

>Mounted at /content/gdrive

```
!ls /content/gdrive/My\ Drive/Colab\ Notebooks/*py
```
 
>'/content/gdrive/My Drive/Colab Notebooks/check1.py'

```
!cat '/content/gdrive/My Drive/Colab Notebooks/check1.py'
```

> def sayHello(x):
>>    print(f'Hello {x}!')

>def sayBye(x):
>>    print(f'Good bye {x}!')

```
import sys
sys.path.append('/content/gdrive/My Drive/Colab Notebooks')
```

```
import check1 as ch

ch.sayHello('Rahul')
ch.sayBye('Rahul')
```

>Hello Rahul!\
Good bye Rahul!

# Mini Project - Sign Up/ Login System
"""

# Username and password
# password strength
#security questions
    # forgot password
    # send OTP
    # change password
# confirm password
# Login status
# Logout
# firebase

# twilio to send sms
# time.sleep(2) to create delay
# random module to create OTP

userData = {}

def signUp():
    while 1:
        userNameS = input(''' 
        Enter ---> a user name
              ---> quit to exit
        ''')

        if userNameS.lower() == 'quit':
            print('Exiting Sign Up...')
            return 'Failed!'
        elif userNameS not in userData:
            passwordS = input('Enter a strong password: ')
            userData.update({userNameS:passwordS})
            return 'Successful!'
        else:
            print('The username already exists. Please try again..')

while 1:    
    mode = input('''
    Enter ---> 1 to Sign Up
          ---> 2 to Log In
          ---> quit to exit  
    ''')

    if mode == '1':
        print('Sign Up', signUp())
    elif mode == '2':
        print('Log In')
        #logIn()
    elif mode.lower() == 'quit':
        print('Exiting...\nThank you!')
        break
    else:
        print('Invalid input.\nPlease try again..')



"""# ***-------->ADVANCED PYTHON<--------***

# Exception Handling
- Exception is an event that stops normal flow of a program during its execution
- When python script raises an exception, it must be handled otherwise it will terminate and quit.

```
import sys

while 1:
    try:
        marks = int(input("Enter Marks: "))
        #raise NameError
    except NameError:
        print(sys.exc_info()[:2])
        break
    except:
        print(sys.exc_info()[:2])
        print("Enter valid input...")
        break
    else:
        if marks > 40:
            print("Passed")
        else:
            print("Failed")
    finally:
        print("Thank you!")
    
```

# Iterators
- It contains countable number of values
- Its values can be iterated upon, i.e, you can traverse through all the values
- It impliments iterator protocol, which consists iter() and next() methods.
    - iter() is used to initialize iterator object
    - next() is used for iteration

```
s = 'Hello'
si = iter(s)

while 1:
    try:
        print(next(si), end=' ')
    except:
        break                       # Output: H e l l o 
```

## Generator functions:
- A generator is a special type of function which does not return a single value, instead, it returns an iterator object with a sequence of values.
- It helps us with Time Space Trade-off as it clears memory after it is used.

### yield statement
- yield keyword is used to return from a function without destroying the states of its local variable and when the function is called, the execution starts from the last yield statement

```
def square(n):
    x = 1
    while 1:
        yield x**2
        x += 1
        if x == n:
            return
```

```
for i in square(5):
    print(i, end=' ')           # Output: 1 4 9 16
```

```
list(square(10))                # Output: [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

# Regular Expression (RegEx) 
- A RegEx, or Regular Expression, is a sequence of characters that forms a search pattern.
- RegEx can be used to check if a string contains the specified search pattern.
"""

import re

s = 'My phone number is +91-9650224909 9650224909'

regex = '(?:[+]91-?)?[\d]{10,13}'
re.findall(regex, s)



"""#File Handling"""

!touch hello.py

!ls

open('hello.py', 'r')

!rm -rf hello.py

!ls

!touch hello.txt

open('hello.txt', 'w').write

!ls /content/sample_data/

open('/content/sample_data/california_housing_test.csv', 'r').readlines(3)

!ls

!rm -rf hello.txt

!ls

fw= open('hello.txt', 'w')

fw.write('Hello there!')

fw.close()

fo = open('hello.txt', 'r')

fo.read()

fa = open('hello.txt', 'a')

fa.write("This just got appended!")

fa.close()

fo

fo.read()

fo.seek(0)

fo.read()

fo.close()

# with statement
# takes care of closing the file

with open('hello.txt', 'w+') as fo:
    fo.read()
    fo.write('Hey!')

fo.read()